Majority-Element-II

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Note: The algorithm should run in linear time and in O(1) space.

Example 1:
Input: [3,2,3]
Output: [3]

Example 2:
Input: [1,1,1,3,3,2,2,2]
Output: [1,2]


# 这道题让我们求出现次数大于n/3的众数，而且限定了时间和空间复杂度，那么就不能排序，也不能使用哈希表，这么苛刻的限制条件只有一种方法能解了，那就是摩尔投票法Moore Voting。
# 题目中给了一条很重要的提示，让我们先考虑可能会有多少个众数，经过举了很多例子分析得出，任意一个数组出现次数大于n/3的众数最多有两个，具体的证明省略。
# 有了这个信息，我们使用投票法的核心是找出两个候选众数进行投票，需要两遍遍历，第一遍历找出两个候选众数，第二遍遍历重新投票验证这两个候选众数是否为众数即可。
# 满足要求的众数可能不存在，所以要有验证。

func majorityElement(nums []int) []int {
    if len(nums) <= 1 {
		return nums
	}
    
    m1, m2, c1, c2 := 0, 0, 0, 0
    for _, e := range nums {
    	if e == m1 {
    		c1++
    	} else if e == m2 {
    		c2++
    	} else if c1 == 0 {
    		m1 = e
            c1 = 1
    	} else if c2 == 0 {
    		m2 = e
            c2 = 1
    	} else {
    		c1--
    		c2--
    	}
    }

    res := []int{}
	if maj(nums, m1) {
		res = append(res,m1)
	}
	if m1 != m2 && maj(nums, m2) {
		res = append(res, m2)
	}

	return res
}

func maj(nums []int, n int) bool {
	c := 0
	for _, e := range nums {
		if e == n {
			c++
		}
	}
	return c > (len(nums) / 3)
}
