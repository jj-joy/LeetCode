303.Range-Sum-Query-Immutable

Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.


/*
动态规划算法
对每一个问题进行分解，设int result = sumRange(i, j);，这个问题实际上可以分解成sumRange(0, j) - sumRange(0, i - 1)。因此，可以将所有sumRange(0, i)的结果都存储下来。
假设用一个新的数组sum来存储，则sum[i] = sumRange(0, i-1)（边界问题我们稍后处理）。
但是，我们别忘了动态规划的思想：根据当前的到的结果推出下一步的结果。sum[0] = nums[0]，sum[1] = nums[0]+nums[1] = sum[0] + num[1]···依次类推，可以得到sum[i] = sum[i - 1] + nums[i]。因此，在初始化时，我们只需要遍历一次nums数组，即可计算出所有位置的sum。

边界问题
按照以上得到的结果，应有sumRange(i, j) = sum[j] - sum[i - 1]。
*/

type NumArray struct {
	// dpSum[i] = sumRange(0, i-1)
    dpSum []int
}

func Constructor(nums []int) NumArray {
    size := len(nums)
    dpSum := make([]int, size+1)
    for i:=0; i<size; i++ {
    	dpSum[i+1] = dpSum[i] + nums[i] 
    }
    return NumArray{dpSum: dpSum}
}

func (this *NumArray) SumRange(i int, j int) int {
	return this.dpSum[j+1] - this.dpSum[i]
}


/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(i,j);
 */